import bullet {
    btDefaultCollisionConfiguration,
    btCollisionDispatcher,
    btDbvtBroadphase,
    btSequentialImpulseConstraintSolver,
    btDiscreteDynamicsWorld,
    btRigidBody,
}

import extern "vector" {
    namespace std {
        extern struct vector<T> {
            function vector<T>() -> vector<T>
            function empty(this) -> bool
        }
    }
}

// class DynamicsWorldStore {
//     collision_configuration: btDefaultCollisionConfiguration
//     dispatcher: btCollisionDispatcher
// }

function main() {
    mut collision_configuration = btDefaultCollisionConfiguration()
    mut dispatcher = btCollisionDispatcher(&raw collision_configuration)
    mut overlapping_pair_cache = btDbvtBroadphase()
    mut solver = btSequentialImpulseConstraintSolver()
    mut world = btDiscreteDynamicsWorld(
        dispatcher: &raw dispatcher,
        overlapping_pair_cache: &raw overlapping_pair_cache,
        solver: &raw solver,
        collision_configuration: &raw collision_configuration,
    )
    defer {
        cleanDynamicsWorld(&mut world)
    }
    let v = std::vector<i32>()
    if v.empty() {
        println("PASS")
    }
    let x = [1, 2, 3]
    println("{}", x[1])
}

function cleanDynamicsWorld(anon world: &mut btDiscreteDynamicsWorld) {
    let num = world.getNumCollisionObjects()
    for i in 0..num {
        mut obj = world.getCollisionObjectArray().at(num - i - 1)
        let body = btRigidBody::upcast(obj)
        unsafe {
            cpp {
                "if (body && body->getMotionState()) {"
                "    delete body->getMotionState();"
                "}"
            }
        }
        world.removeCollisionObject(obj);
        unsafe { cpp { "delete obj;" } }
    }
}

import extern "btBulletDynamicsCommon.h" {
    extern struct btDefaultCollisionConfiguration {
        public function btDefaultCollisionConfiguration() -> btDefaultCollisionConfiguration
    }

    extern struct btCollisionDispatcher {
        public function btCollisionDispatcher(
            anon collisionConfiguration: raw btDefaultCollisionConfiguration
        ) -> btCollisionDispatcher
    }

    extern struct btDbvtBroadphase {
        public function btDbvtBroadphase() -> btDbvtBroadphase
    }

    extern struct btSequentialImpulseConstraintSolver {
        public function btSequentialImpulseConstraintSolver() -> btSequentialImpulseConstraintSolver
    }

    extern struct btAlignedObjectArray<T> {
        function at(this, anon n: i32) -> T
    }

    extern struct btCollisionObject { }

    extern struct btDiscreteDynamicsWorld {
        public function btDiscreteDynamicsWorld(
            dispatcher: raw btCollisionDispatcher, overlappingPairCache: raw btDbvtBroadphase, solver: raw btSequentialImpulseConstraintSolver, collisionConfiguration: raw btDefaultCollisionConfiguration
        ) -> btDiscreteDynamicsWorld

        public function getCollisionObjectArray(this) -> &btAlignedObjectArray<raw btCollisionObject>

        public function getNumCollisionObjects(this) -> i32
    }
}

import extern "vector" {
    namespace std {
        extern struct vector<T> {
            function vector<T>() -> vector<T>
            function empty(this) -> bool
        }
    }
}

// class DynamicsWorldStore {
//     collisionConfiguration: btDefaultCollisionConfiguration
//     dispatcher: btCollisionDispatcher
// }

function main() {
    mut collisionConfiguration = btDefaultCollisionConfiguration()
    mut dispatcher = btCollisionDispatcher(&raw collisionConfiguration)
    mut overlappingPairCache = btDbvtBroadphase()
    mut solver = btSequentialImpulseConstraintSolver()
    mut world = btDiscreteDynamicsWorld(
        dispatcher: &raw dispatcher,
        overlappingPairCache: &raw overlappingPairCache,
        solver: &raw solver,
        collisionConfiguration: &raw collisionConfiguration,
    )
    defer {
        cleanDynamicsWorld(&world)
    }
    let v = std::vector<i32>()
    if v.empty() {
        println("PASS")
    }
    let x = [1, 2, 3]
    println("{}", x[1])
}

function cleanDynamicsWorld(anon world: &btDiscreteDynamicsWorld) {
    let num = world.getNumCollisionObjects()
    for i in 0..num {
        let obj = world.getCollisionObjectArray().at(num - i - 1)
    }
    // for (int i = world.getNumCollisionObjects() - 1; i >= 0; i--) {
    //     btCollisionObject* obj = world.getCollisionObjectArray()[i];
    //     btRigidBody* body = btRigidBody::upcast(obj);
    //     if (body && body->getMotionState()) {
    //         delete body->getMotionState();
    //     }
    //     world.removeCollisionObject(obj);
    //     delete obj;
    // }
}

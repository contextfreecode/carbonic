import bullet {
    btCollisionDispatcher,
    btCollisionShape,
    btDbvtBroadphase,
    btDefaultCollisionConfiguration,
    btDiscreteDynamicsWorld,
    btSequentialImpulseConstraintSolver,
    btRigidBody,
    btTransform,
    btVector3,
}

import extern "vector" {
    namespace std {
        extern struct vector<T> {
            function vector<T>() -> vector<T>
            function empty(this) -> bool
        }
    }
}

// class DynamicsWorldStore {
//     collision_configuration: btDefaultCollisionConfiguration
//     dispatcher: btCollisionDispatcher
// }

function main() {
    mut collision_configuration = btDefaultCollisionConfiguration()
    mut dispatcher = btCollisionDispatcher(&raw collision_configuration)
    mut overlapping_pair_cache = btDbvtBroadphase()
    mut solver = btSequentialImpulseConstraintSolver()
    mut world = btDiscreteDynamicsWorld(
        dispatcher: &raw dispatcher,
        overlapping_pair_cache: &raw overlapping_pair_cache,
        solver: &raw solver,
        collision_configuration: &raw collision_configuration,
    )
    defer {
        clean_dynamics_world(&mut world)
    }
    let v = std::vector<i32>()
    if v.empty() {
        println("PASS")
    }
    let x = [1, 2, 3]
    println("{}", x[1])
}

function clean_dynamics_world(anon world: &mut btDiscreteDynamicsWorld) {
    let num = world.getNumCollisionObjects()
    for i in 0..num {
        mut obj = world.getCollisionObjectArray().at(num - i - 1)
        let body = btRigidBody::upcast(obj)
        unsafe {
            cpp {
                "if (body && body->getMotionState()) {"
                "    delete body->getMotionState();"
                "}"
            }
        }
        world.removeCollisionObject(obj);
        unsafe { cpp { "delete obj;" } }
    }
}

function init_body(mass: f32, origin: btVector3, shape: &mut btCollisionShape) {
    mut transform = btTransform()
    transform.setIdentity()
    transform.setOrigin(&origin)
    let isDynamic = mass != 0f32
    let localInertia = btVector3(0f32, 0f32, 0f32)
    // if (isDynamic) init.shape->calculateLocalInertia(init.mass, localInertia);
    // btDefaultMotionState* myMotionState = new btDefaultMotionState(transform);
    // btRigidBody::btRigidBodyConstructionInfo rbInfo(init.mass, myMotionState,
    //                                                 init.shape, localInertia);
    // return new btRigidBody(rbInfo);
}
